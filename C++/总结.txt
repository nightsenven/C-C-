一、什么是面向过程？
    C语言解决问题的时候是依照问题的解决步骤，思路去封装函数，然后按照步骤依次调用函数。
二、什么是面向对象思想？
    面向对象思想是指以“事物”为中心的编程思想，它的目的性不及面向过程的目的性强。
封装、继承、多态只有事物才具有的，而过程是不具有的。
    对象是人们要进行研究的任何事物；
    对象具有状态，一个对象用数据值来描述它的状态；
    对象还有操作，用于改变对象的状态，操作就是对象的行为；
    对象实现了数据和操作的结合，使数据和操作封装于对象的统一体中。
    具有相同或相似性质的对象的抽象就是类。
    对象的唯一性：每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象。在对象的
整个生命期中，它的标识都不改变，不同的对象不能有相同的标识。
三、为什么会出现C++？
    为了应对复杂的大型应用程序开发---》C++产生(继承了C语言所有的语法点，在此基础上添加
了面向对象的语法规则)，C++是C语言的超集。
四、函数重载
    C++中允许出现相同名字的函数，具备不同的表现形式，实现了接口的统一；
    原理：编译器在编译程序的时候，会自动把函数替换成对应版本重载形式。
    特点：
        1）函数重载不关心返回值类型，返回值类型不同，其它的都一样(函数名字，参数个数类型)，不叫函数重载
        2）函数重载，函数名必须相同
        3）函数重载，参数的个数或者类型至少要有一个是不同的
五、命名空间（名称空间）
    作用：跟C语言static有点类似，解决变量名字冲突的问题
    语法规则：
              namespace  命名空间的名字
              {
                  包含的内容
                  包含变量
                  包含函数
              }
     写法：1）. namespace yy{ }     yy::变量的名字;     //::称作作用域解析运算符
           2）.using namespace yy; （慎用） //使用using预编译指令声明要使用
六、引用&
    定义：变量的一个别名。对引用的操作与对变量直接操作完全一样。
    1、与指针的区别
    引用是C++对C语言的一个重要的扩展，与指针类似，但仍有一些不同点，主要分为以下几点：
        1）从内存上讲，系统为指针分配内存空间，而引用与绑定的对象共享内存空间，系统不为
    引用变量分配内容空间（内容空间不是其自身空间，在C++内部实现是一个常指针，4字节）；
        2）指针初始化以后可以更改指向对象，而引用定义的时候必须要初始化，且初始化以后不
    允许重新再绑定对象；
        3）所以引用空间对象是直接访问，指针访问对象是间接；
        4）如pa是指针，*pa就是引用；
    2、引用特点
        1）引用仅仅只是变量的一个别名，不占用额外的内存空间，好处在于可以节约内存空间(
    引用占用的空间，就是那个变量的空间)
         应用：引用作为函数的形参
        2）引用具备了传值和传地址的双重属性
        3）引用必须在定义的时候立马初始化(例外的情况：引用作为参数除外)
    3、引用应用
        1）引用作为参数
            优点：使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参
        操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效 率和所占空间都好。
        2）常引用
            书写格式：const 类型标识符 &引用名 = 目标变量名；
            用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标
        成为const，达到了引用的安全性。
        3）引用作为返回值
            书写格式：类型标识符 &函数名（形参列表及类型说明）
　　                  {函数体}
            优点：用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。
          引用作为返回值，必须遵守以下规则：
            1.不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返
          回的引用就成为了"无所指"的引用，程序会进入未知状态。
　　        2.不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题， 可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak（内存泄漏）。
            3.可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]
          的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
　　        4.引用作为左值时：用返回引用的函数值作为赋值表达式的左值。
　　          例：流操作符<<和>>、赋值操作符=的重载。
            5.引用和多态
                概念：引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的
              引用可以指向它的派生类实例。
        总结：
            （1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。
            （2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。
            （3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。
            （4）使用引用的时机。流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。
七、函数带默认参数
    特点:
        1)程序员调用的时候可以选择是否传递实参，如果传递实参就使用程序员传递的
    如果不传递，就使用默认的。
        2)传递参数的时候必须从左到右连续,函数定义的时候参数必须从右到左连续默认。
八、类
    1、构造函数
        语法规则：
            类名(形参列表)
                 {
                      代码
                 }
        实际应用：往往用来初始化对象。（对象创建时自动调用）
        特点：
            第一：构造函数的名字必须跟类名相同
            第二：构造函数没有返回值类型
            第三：如果程序员没有定义构造函数，系统会自动帮你生成一个无参的构造函数
            Animal()
            {
                     什么事情都不做，只帮你创建对象，分配空间
           }
           如果程序员自定义构造函数(无论是否带参数)，那么系统就不会再自动生成默认的构造函数
 第四：构造函数可以重载，重载构造函数是为了实现创建对象的多样化。
    2、析构函数
        语法规则： ~类名()
                  {
                          代码
                 }
        实际应用：往往用来做收尾工作。（对象地址空间释放时自动调用）
        特点：
             第一个：析构函数没有任何重载形式
             第二个：析构函数没有任何参数
             第三个：如果程序员没有定义析构函数，系统会自动帮你生成一个析构函数
                       ~Animal()
                        {
                                 什么事情都不做
                       }
             如果程序员自定义析构函数，那么系统就不会再自动生成默认的析构函数
     3、拷贝构造函数
        语法规则：类名(类名 &)
                 {
                        代码
                 }
         原理：用一个对象去初始化另外一个对象的时候就会自动调用拷贝构造函数。
         特点：
               第一：没有重载形式
               第二：一定是用对象初始化另一个对象才调用
               第三：如果程序员没有定义拷贝构造函数，系统会自动帮你生成一个拷贝构造函数
                   Animal(Animal &other)
                    {
                            other中的数据赋值给this
                   }
               如果程序员自定义析构函数，那么系统就不会再自动生成默认的析构函数。
        深拷贝：程序员自己动手写个拷贝构造函数，解决浅拷贝的bug，这个自定义的拷贝构造函数实现就是深拷贝
        浅拷贝：指的就是使用系统默认的拷贝构造函数，构造出来的新对象共用同一块堆空间，一旦某个对象修改了堆空间中的数据，其它对象全部跟着修改，这种现象称之为浅拷贝
    思考：构造函数一般都定义成公有的，如果定义成私有的，有什么后果？？
            答：如果将类中的构造函数定义成私有，那么这个类就不能够创建实例，但是也同时保证了其他类不能从这个类中派生。
九、继承和派生
    概念和作用
      继承： 描述的是生活中is-a这种关系
             Cat继承Animal类 //Cat  is a Animal
      派生：
             Animal派生出Cat
      子类(派生类)：
      父类(基类)：被继承的那个类就是父类
      好处作用：提高代码的复用性 //子类如果继承了父类，子类可以直接使用父类的公有方法。
    语法规则：
        class  子类的名字:pubic    父类的名字  //公有继承
        class  子类的名字:private  父类的名字  //私有继承    has-a
        class  子类的名字:protected  父类的名字  //保护继承
        {
                子类的成员
         };
    子类继承了父类，子类究竟可以使用父类的哪些成员
       公有继承：         公有成员         保护成员        私有成员
     情况一：在子类的外部     ok              NO             NO
     情况二：在子类的内部     ok              ok             NO
       保护继承：         公有成员         保护成员       私有成员
     情况一：在子类的外部     NO              NO             NO
     情况二：在子类的内部     ok              ok             NO
       私有继承：         公有成员         保护成员       私有成员
     情况一：在子类的外部     NO              NO             NO
     情况二：在子类的内部     ok              ok             NO
      绝大部分情况都采用公有继承。
      子类继承分类之后：
            程序员指定要调用父类某个版本的构造函数（使用形参列表形式）
             子类构造(形参列表):父类构造(传递给父类的实参)
             {
             }
     如果子类出现了父类的名字相同参数也相同的方法函数，如何使用子类对象调用父类或者子类
    的方法？
       答：1）子类对象调用自己的与父类相同的方法，如：Cat.eat()  //使用子类自己的eat，父类是Anima。
          2）子类对象指定调用父类的同名方法，如：Cat.Animal::eat()  //使用父类的eat
十、多重继承
    第一种：子类继承了多个父类。
    第二种：父类派生出子类，子类再派生出子子类，以此类推。
            如：A派生出B，B派生出C，C接着派生。
    语法规则：
           class  子类的名字:pubic  父类1,public 父类2  //公有继承（一般使用公有继承）
           {
           };
    多重继承产出的问题：
        1）子类继承的父类的时候，父类会被构建多次，浪费了存储空间（希望父类只要被构建一次）。
        2）二义性问题，当存在问题1）时，子类调用父类的方法会产生二义性。
    解决：
        使用虚继承解决多重继承遇到的问题。
            语法规则：class  子类:virtual  public  父类
                       {
                       }
           底层原理：虚基类表。C++中专门用来存放虚基类地址的一种数据结构。
           总结：普通继承跟虚继承的区别
                第一：虚继承可以解决二义性和A被构建多次这两个问题，普通继承不能解决
                第二：只要一个类虚继承了其它类，那么该类所有的对象中都会新增一个指针，该指针专门用来指向系统中虚基类表的首地址
十一、const和static的用途(重点)
    1. const的用途
       第一：const 修饰成员变量
                    作用：表示常量
                    只能在构造函数的参数列表初始化中赋值
       第二：const修饰成员函数
                    写法：返回值  函数名()  const     //const放在函数声明的后面
                    作用：防止该成员函数修改类的成员变量
                             不论成员变量是const修饰，还是普通变量，都不能修改，只能访问
       第三：const修饰引用
                    常引用，表示该引用不能修改指向的变量
   2. static的用途
       静态成员：类的成员使用static修饰，那么就是静态成员
                      静态成员优先于类的对象存在，不需要定义对象，静态成员已经在数据段中存放着
       第一：修饰成员变量
                      静态成员数据需要在类的外面初始化赋值
                      静态成员数据是该类所有的对象共享的(所有的对象使用同一个静态成员)
                      静态成员数据不占用类的地址空间，类的大小不包含静态成员数据的大小
       第二：修饰成员函数
                      静态成员函数可以通过类名直接调用(不需要定义对象，直接用类名即可调用)
                      静态成员函数中只能使用static修饰的成员变量，非static修饰不能使用
                      应用：作为工具类使用
                      工具类：该类专门提供算法函数给别人使用
                         class Math公式
                         {
                           public:
                                     static 求偏导数();
                                     static 求积分();
                                     static 求无人机飞行加速度和角速度();
                         }；
                      Math公式::求偏导数();   //不需要定义对象，直接调用
