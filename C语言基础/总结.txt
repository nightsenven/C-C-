1、printf函数：输出数据到屏幕
  头文件：#include <stdio.h>
  函数原型：int printf(const char *format, ...);  --》变参函数
  返回值：是正常打印了字符的数量。
    1.1、printf颜色字体控制
      控制输出字体的颜色和显示方式
      转义序列:以‘ESC’字符开头，八进制033，十进制27，十六进制1B。以‘ESC’字符加上‘[’开头。可以由’ \033[’或’\e[’。
      常见格式：\033[显示方式；前景色；背景色m输出字符串\033[0m
      显示方式：0（默认）、1（高亮/粗体）、22（非粗体）、4（单条下划线）、24（无下划线）、7（反显）、27（无反显）
      前景色：用30+为颜色值， 32代表前景色为绿色
      背景色：用40+为颜色值，45代表背景色为洋红
      颜色：0（黑色），1（红），2（绿），3（黄），4（蓝），5（洋红），6（青），7（白色）
2、scanf函数：从键盘获取数据
  头文件：#include <stdio.h>
  函数原型：int scanf(const char *format, ...);
  返回值：代表正确拿到了多少个数据。
  注意：在scanf函数的第一个参数中不写其他的东西，只写格式控制符。
3、位运算符
    3.1、位逻辑反： 运算符后面接变量名，是将变量中的所有位进行取反（包括符号位）。
    3.2、位逻辑与和位逻辑或：是双目运算符，左右两边分别跟上一个操作数，将两个操作数的每一位进行与/或运算。
        例子：与运算：两个逻辑值有0则0，没0则1；
               char a =0x14， b = 0x36;
               a&b = 0001 0100 & 0011 0110 = 0001 0100 = 0x14;
               或运算：两个逻辑值有1则1，没1则0；
               char a =0x14， b = 0x36;
               a|b = 0001 0100 | 0011 0110 = 0011 0110=0x36
    3.3、位逻辑异或：两个逻辑值不同就为1，相同就为0。将两个操作数的每一位进行异或运算。
        例子：
            char a =0x14， b = 0x36;
      a^b = 0001 0100 ^ 0011 0110 = 0010 0010 = 0x22;
       简单应用：
            ①、加密： b^0x22 = 0011 0110^0010 0010 = 0001 0100 = 0x14，假设a是数据，b是密钥，0x22是传输的数据。
            ②、值交换：a=a^b; b=a^b;a=a^b;
    例题：求100到200之间的素数。（只有1和本身能整除的数）
        #include <stdio.h>
        int main(void)
        {
            int k = 0,i = 100;
            for(; i <= 200; i++)
            {
                for(k = 2; k <= i; k++)
                {
                    if(i%k == 0)
                    {
                        break;
                    }
                }
                if(k >= i)
                {
                    printf("%d\n",i);
                }
            }
            return 0;
        }

4、内联函数： 建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。（以空间换时间）
  为什么使用内联函数？
    解决函数的执行时间与保护现场和恢复现场所需时间相近，多次调用函数造成时间效率低。
  内联函数的要求：（注意：内联函数必须要是静态的）
    ①、函数足够简单，执行时间和函数切换时间在同一个数量级。
    ②、函数在程序中调用的次数足够多。
5、数组和指针的不同点
    指针：保存数据的地址；间接访问数据，首先取得指针的内容，然后从这个地址取得数据。
    数组：保存数据；直接访问数据。
  相同点：
    ①、表达式中的数组名就是指针；
    ②、数组下标作为指针的偏移量；
    ③、作为函数参数的数组名等同于指针变量。
6、多级指针
	1.数组指针：指向数组的指针，int (*p)[];  p先和*结合变成指针，在用int []表示这个指针的类型。
	2.指针数组：数组的每一个元素都是指针，int *p[n];p先和[]结合变成数组，定义数组中有n个int *型的元素。
	3.函数指针：指向函数的指针，int(*p)(int); p先和*结合变成指针，int （int）就是指针指向的函数的类型。
	4.指针函数：返回值为指针的函数，int *p(int); p先和小括号结合，形成函数，（int）代表参数列表，int *代表返回值类型。
	5.函数指针数组：一个数组中每一个元素都是一个函数指针。Int (*p[])(int)；p先和[]结合，变成数组，在和*号结合表明每一个元素都是一个指针，int (int)表示每一个指针的类型是函数指针。

7、字符串操作函数
    ①、strlen：获取字符串长度，从字符串开头到\0为止，\0不算在内
       ②、strcpy：复制字符串
 strncpy
       ③、strcat：字符串连接，追加
           strncat
       ④、strcmp：比较字符串大小，用来判断两个字符串是否相同
            strcnmp
       ⑤、strstr：查找字符串中首次出现的子串
            strnstr
       ⑥、bzero  对字符串中指定个数置零
8、存储类的说明符
    ①、auto：声明一个自动变量（局部变量和临时变量且必须声明是初始化），默认变量的说明符
。auto会忽略顶层const。
    decltype：会保留顶层const。
    ②、static：声明静态变量，声明一个内部链接的函数和全局变量。
            修饰局部变量
                普通局部变量  —》静态局部变量
    存储空间：栈空间 --》数据段
    存储期：自动存储期 --》静态存储期
    链接：  无链接   --》 无链接
                修饰全局变量
                    普通全局变量 –》 静态全局变量
    存储空间：数据段   --》  数据段
    存储期：静态存储期  --》 静态存储期
    链接：  外部链接   --》  内部链接
                修饰函数
                    普通函数  --》 静态函数
                    链接： 外部链接  --》 内部链接
        ③、register：声明一个寄存器存储类变量。
        ④、extern：声明一个外部存储变量。
        ⑤、typedef：语法意义上的存储类，与实际存储类类型无关。
        ⑥、const：定义只读变量，该变量值不能再被修改；所以在定义const变量时就必须初始化。
            1、预编译指令只是对值进行简单的替换，不能进行类型检查
            2、可以保护被修饰的东西，防止意外修改，增强程序的健壮性
            3、编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
            基本用法：
                ①、修饰局部变量：const int n = 5; int const n = 5;
                    这两种写法是一样的，表示变量n的值不能被改变。一般用const修饰时就立马初始化，否则只会不能赋值。
                ②、常量指针和指针常量
                     常量指针是指针指向的内容是常量。写法：const int *n;或者 int const *n;
                     注意：1.常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的。
                            如：int a=5;const int* n=&a;a=6;
                           2.常量指针指向的值不能改变，但是这并不是意味着指针本身不能改变，常量指针可以指向其他的地址。
                            如：int a=5;int c=7;const int* n=&a;a=6;n=&c;
                     指针常量是指指针本身是个常量，不能在指向其他的地址。写法：int *const n;
                      注意： 指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改。
                            如：int a=6;int *p=&a;int *const n=&a;*p=8;
                ③、 指向常量的常指针
                        指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值。
                        写法：const int *const p;
                ④、修饰函数的参数
                    作用：①、防止修改指针指向的内容。如：void fun(char *src,const char*dest);
                          ②、防止修改指针指向的地址。如：void fun(int *const p1,int *const p2);
                          ③、防止修改指针指向的内容和地址。如： void fun(int *const p1,const int * p2);
                ⑤、修饰函数的返回值
                     如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。如：const char *fun();调用该函数时应该这样调用：const char *str = fun();
                ⑥、修饰全局变量
                     全局变量的作用域是整个文件，我们应该尽量避免使用全局变量，因为一旦有一个函数改变了全局变量的值，它也会影响到其他引用这个变量的函数，导致除了bug后很难发现，如果一定要用全局变量，我们应该尽量的使用const修饰符进行修饰，这样防止不必要的人为修改，使用的方法与局部变量是相同的。
            const用法总结：
                如果该变量为全局变量，则不能通过指针修改，但如果是局部变量，则还是可以通过指针修改的。
                原因是：全局变量在全局静态区，内容不能被修改，但局部变量本身仍在栈区，可以使用指针修改。
